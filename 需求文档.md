## 高并发设备数据接入与查询服务 — 需求规格说明书

### 1. 文档头部

- **项目名称**：高并发设备数据接入与查询服务（Linux C++ 后端）
- **版本号**：v1.0
- **编写日期**：2026-01-23
- **适用阶段**：需求分析 / 架构设计 / 开发实现
- **文档说明**：
  - 本文档基于 `原始信息` 中的项目描述整理，面向后端开发、架构设计及技术面试场景。
  - 文档约束了项目的业务范围、技术栈选择、主要功能、性能目标以及总体架构与模块划分。

---

### 2. 业务背景

- **业务场景描述**  
  公司拥有大量分布在各地的 IoT / 医疗 / 工业设备，这些设备会持续、实时地往云端上报运行状态、监测指标等数据。  
  后端系统需要提供稳定、高并发的数据接入通道，并对历史数据提供高效查询能力。

- **核心业务需求**
  - 接收来自大量设备的实时数据上报。
  - 将数据可靠地进行存储（先内存缓存，后落到持久化存储）。
  - 对指定设备的数据提供按时间顺序的查询能力，支持分页/数量限制。
  - 在高并发场景下保证服务的稳定性、低延迟和可扩展性。

- **应用领域**
  - IoT 设备监控
  - 医疗设备（如心电监护仪、血氧仪等）数据采集
  - 工业设备状态监控与告警

---

### 3. 技术栈要求

- **必须使用的技术栈**
  - **操作系统**：Linux（Ubuntu / CentOS 均可）
  - **编程语言**：C++17
  - **网络通信**：
    - TCP Socket / HTTP 二选一，**推荐 HTTP**：
      - 若选择 HTTP：自实现基础 HTTP 解析 / 组包逻辑，不依赖高层 Web 框架。
      - 若选择原生 TCP：需自定义简单的应用层协议。
  - **多线程**：`pthread` 或 `std::thread`
  - **构建系统**：CMake
  - **日志**：
    - 自研简易日志模块，或使用 `spdlog`
  - **数据存储方案**：
    - 第一阶段：内存存储（`std::unordered_map` / 环形缓冲区 ring buffer 等）
    - 第二阶段（进阶）：MySQL / SQLite / Redis（三者任选一种，或支持多种实现）

- **禁止使用的技术**
  - 禁止直接使用现成 C++ Web 框架，如：
    - Drogon
    - cpprestsdk
    - 以及类似提供完整 HTTP 服务器能力的高层框架

- **技术选型目的**
  - 强化 Linux 环境下 C++ 网络编程与多线程编程能力。
  - 深入理解 Socket、HTTP 报文解析、JSON 解析等底层细节。
  - 通过自行实现线程池、任务队列、异步落库等机制，训练对高并发后端系统的整体把控能力。

---

### 4. 功能需求

#### 4.1 设备数据上报接口（核心）

- **接口定义（建议 HTTP 实现）**
  - 方法：`POST`
  - 路径：`/api/v1/device/report`
  - 请求头（示例）：
    - `Content-Type: application/json; charset=utf-8`
  - 请求体（JSON 示例）：

```json
{
  "device_id": "ECG_10086",
  "timestamp": 1700000000,
  "metrics": {
    "heart_rate": 78,
    "spo2": 98
  }
}
```

- **字段说明**
  - `device_id`：字符串，设备唯一标识，如医疗设备编号、SN 号等。
  - `timestamp`：整型，Unix 时间戳（秒或毫秒，需在实现中统一约定）。
  - `metrics`：对象，设备上报的指标集合，键为指标名，值为数值或字符串。
    - 示例字段：`heart_rate`（心率）、`spo2`（血氧饱和度）等。

- **服务端处理流程要求**
  1. **参数校验**
     - 检查 `device_id` 是否为空。
     - 检查 `timestamp` 是否为合法时间戳。
     - 检查 `metrics` 非空且为合法 JSON 对象。
     - 请求体非法时返回 4xx 错误（如 `400 Bad Request`）及错误描述。
  2. **设备自动注册**
     - 若系统中尚不存在该 `device_id`，则自动创建设备记录（在内存/数据库中标记注册）。
  3. **数据写入内存缓冲区**
     - 将上报数据写入内存中的数据结构（如 `unordered_map<device_id, ring_buffer>`）。
     - 写入过程需保证线程安全。
  4. **异步落库（不能阻塞网络线程）**
     - 网络线程仅负责解析请求、校验并将数据投递到**生产者队列**。
     - 独立的数据写入线程（或线程池）从队列中消费数据，异步写入后端存储（内存 + DB）。
  5. **返回结果**
     - 成功：`200 OK`，返回 JSON：

```json
{
  "code": 0,
  "message": "ok"
}
```

     - 失败：返回对应错误码（如 `code != 0`）及错误信息。

- **关键技术要点（练习点）**
  - Socket 读写与连接管理。
  - HTTP 报文解析与组装（请求行、头部、Body）。
  - JSON 解析与序列化。
  - 生产者-消费者模型设计（上报数据进入队列，落库线程消费）。
  - 多线程环境下的数据结构设计与线程安全。

---

#### 4.2 设备数据查询接口

- **接口定义**
  - 方法：`GET`
  - 路径：`/api/v1/device/query`
  - 请求参数示例：
    - `device_id=ECG_10086`
    - `limit=100`
  - 示例：`GET /api/v1/device/query?device_id=ECG_10086&limit=100`

- **请求参数说明**
  - `device_id`（必填）：要查询的设备 ID。
  - `limit`（选填）：返回数据条数上限，默认值可为 100，上限可配置（如 1000）。

- **返回数据示例**

```json
{
  "device_id": "ECG_10086",
  "data": [
    { "timestamp": 1700000000, "heart_rate": 78 },
    { "timestamp": 1700000010, "heart_rate": 80 }
  ]
}
```

- **功能与约束要求**
  - 支持按 `device_id` 查询最近的若干条数据，数量由 `limit` 控制。
  - **查询不能阻塞写入**：
    - 读写分离设计，避免读取长时间持有写锁。
    - 可采用读写锁（RWLock）、多副本或 copy-on-write 等方案。
  - 数据结构设计需兼顾：
    - 时间有序；
    - 快速插入（写入）；
    - 快速按设备查询最近 N 条记录。

- **设计思考点**
  - 典型场景为**读多写少**或读写均衡：需要权衡以下几种方案：
    - 使用读写锁（shared_mutex 等），多读单写。
    - 使用 copy-on-write，写入时复制，读操作无锁或轻锁。
    - 为每个设备维护一个环形缓冲区（固定容量，自动淘汰最旧数据）。

---

#### 4.3 高并发与性能要求

- **并发连接数**
  - 支持至少 **1 万条长连接**（10,000 concurrent connections）。

- **QPS 目标**
  - 峰值 QPS ≥ **2000**（每秒处理请求数）。

- **响应时间**
  - 在仅使用内存模式（不访问慢速磁盘存储）的前提下：
    - 单次请求平均响应时间 **< 10ms**。

- **涉及技术点**
  - IO 模型选择：
    - 阻塞 / 非阻塞 Socket；
    - 建议使用 `epoll` 等多路复用机制（Linux）。
  - 线程池设计：
    - 限制线程数量，避免为每个连接创建独立线程。
    - 合理设置线程池大小（CPU 密集 vs IO 密集）。
  - epoll 进阶使用：
    - 水平触发（LT）/ 边缘触发（ET）策略；
    - 连接可读/可写事件处理。

---

### 5. 架构设计要求

- **进程与线程模型（示例）**

  - `main` 进程启动后，整体结构参考：
    - 网络线程（基于 epoll 的 Reactor 或简化版本）：
      - 负责监听端口、接受连接、收发数据、解析协议。
    - 业务线程池：
      - 负责处理解析后的业务请求（上报 / 查询），调用业务逻辑模块。
    - 数据写入线程：
      - 从队列中异步消费上报数据，写入内存结构及持久化存储。
    - 日志线程：
      - 异步写日志文件，避免阻塞业务线程。

- **需要开发者决策的点**
  - 网络线程数量：
    - 单 Reactor + 多工作线程，或多 Reactor 模式。
  - 业务线程池大小：
    - 可根据 CPU 核心数设定（例如 N 或 2N）。
  - 队列模型：
    - 有锁队列（简单易实现）。
    - 无锁队列（进阶，降低锁竞争）。

- **数据流大致流程描述**
  1. 设备通过 TCP/HTTP 建立连接并发送请求。
  2. 网络线程接收数据，解析 HTTP/JSON，封装为内部请求对象。
  3. 对于上报请求：
     - 投递到业务线程或数据写入队列；
     - 业务线程更新内存结构，数据写入线程负责异步持久化。
  4. 对于查询请求：
     - 业务线程从内存结构（以及必要时的持久化存储）读取数据；
     - 将结果序列化为 JSON 回写给客户端。

---

### 6. 模块划分与目录结构

- **推荐目录结构**

```text
src/
├── net/
│   ├── TcpServer.cpp
│   ├── HttpParser.cpp
│   └── Connection.cpp
├── thread/
│   ├── ThreadPool.cpp
│   └── BlockingQueue.hpp
├── business/
│   ├── DeviceManager.cpp
│   └── ReportHandler.cpp
├── storage/
│   ├── MemoryStore.cpp
│   └── DbWriter.cpp
├── utils/
│   ├── Logger.cpp
│   └── Config.cpp (可选)
└── main.cpp
```

- **各模块职责说明（概要）**
  - `net` 模块：
    - 封装 Socket/epoll 相关逻辑。
    - 负责连接管理、数据收发、HTTP 解析。
  - `thread` 模块：
    - 提供通用线程池实现。
    - 提供阻塞队列 / 无锁队列等并发数据结构。
  - `business` 模块：
    - 设备管理（注册、状态维护）。
    - 上报处理逻辑、查询逻辑路由与结果组装。
  - `storage` 模块：
    - 内存存储结构（按设备组织的 ring buffer 或 list 等）。
    - 后续扩展的数据库写入、批量刷盘等。
  - `utils` 模块：
    - 日志组件、配置加载、通用工具函数等。

- **模块间依赖关系（简要）**
  - `main` 依赖 `net`、`thread`、`business`、`storage`、`utils`。
  - `business` 依赖 `storage`、`utils`。
  - `net` 依赖 `thread`（可选，用于网络层任务分发）、`utils`。
  - `storage` 依赖 `utils`。

---

### 7. 非功能性需求

- **性能指标**
  - 并发连接数 ≥ 10,000。
  - 峰值 QPS ≥ 2,000。
  - 内存模式下单次请求平均响应时间 < 10ms。

- **可扩展性要求**
  - 代码结构清晰，模块解耦，方便后续：
    - 切换或增加持久化存储（如从 SQLite 升级到 MySQL/Redis）。
    - 增加新的业务接口（如告警、统计聚合等）。
  - 预留水平扩展空间：
    - 支持多实例部署，通过负载均衡器分流流量。

- **稳定性要求**
  - 处理异常输入时不会导致进程崩溃。
  - 网络异常、数据库异常时有重试或降级策略（可在进阶阶段实现）。
  - 日志记录关键事件，便于排查问题。

---

### 8. 开发阶段规划

- **第一阶段：内存存储版（必做）**
  - 使用内存数据结构（`unordered_map` + ring buffer 或 vector/list 等）存储数据。
  - 实现完整的设备上报与查询接口。
  - 实现基础的线程池、生产者-消费者队列。
  - 完成基本的性能测试，验证在单机上满足基本并发 / 延迟要求（可适当降低目标作为训练）。

- **第二阶段：持久化存储版（进阶）**
  - 引入 MySQL / SQLite / Redis 之一作为持久化层。
  - 数据写入线程将内存缓冲的数据批量或实时写入数据库。
  - 查询接口可支持：
    - 仅查内存中近期数据；或
    - 内存 + 数据库联合查询（需要合理的时间范围或分层策略）。
  - 增加更多的健壮性和运维相关能力（如配置文件、启动参数等）。

---

### 9. 交付物

- 代码仓库（含 CMake 构建脚本、源码、示例配置）。
- 可执行服务程序（运行于 Linux 环境）。
- 基本使用文档（启动方式、简单压测方法）。
- 本需求规格说明书（可由 Markdown 转为 Word / PDF 进行归档）。 


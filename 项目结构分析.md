# 高并发设备数据接入与查询服务 - 项目结构分析

## 📋 项目概述

这是一个基于 **Linux C++** 的高并发设备数据上报与查询服务，采用 **epoll** 实现高并发网络处理，支持设备数据的实时上报和历史查询。

### 核心功能
- ✅ 设备数据上报（HTTP POST）
- ✅ 设备数据查询（HTTP GET）
- ✅ 高并发支持（基于 epoll 的 Reactor 模式）
- ✅ 内存存储（读写锁保护）
- ✅ 自动设备注册

---

## 🏗️ 项目目录结构

```
Linux cpp backend/
├── CMakeLists.txt              # CMake 构建配置
├── README.md                   # 项目说明文档
├── 项目结构分析.md             # 本文档
├── src/
│   ├── main.cpp               # 程序入口，初始化各模块并启动服务器
│   │
│   ├── net/                   # 网络模块（核心）
│   │   ├── TcpServer.hpp/cpp  # TCP 服务器（epoll 实现）
│   │   ├── Connection.hpp/cpp # 连接管理（读写缓冲区）
│   │   └── HttpParser.hpp/cpp # HTTP 请求/响应解析器
│   │
│   ├── business/              # 业务逻辑模块
│   │   ├── ReportHandler.hpp/cpp  # 上报/查询请求处理
│   │   └── DeviceManager.hpp/cpp  # 设备注册管理
│   │
│   ├── storage/               # 存储模块
│   │   └── MemoryStore.hpp/cpp    # 内存存储（读写锁）
│   │
│   ├── thread/                # 线程模块（当前未使用，但已实现）
│   │   ├── ThreadPool.hpp/cpp     # 线程池
│   │   └── BlockingQueue.hpp      # 阻塞队列（模板类）
│   │
│   └── utils/                 # 工具模块
│       ├── Logger.hpp/cpp          # 日志系统
│       └── JsonParser.hpp/cpp      # JSON 解析器（自实现）
```

---

## 🔍 模块详细分析

### 1. 网络模块（net/）

#### 1.1 TcpServer（TCP 服务器）
**文件**：`TcpServer.hpp/cpp`

**核心职责**：
- 基于 **epoll** 实现 Reactor 模式
- 管理监听套接字和客户端连接
- 使用边缘触发（ET）模式提高性能

**关键实现**：
```cpp
// 核心数据结构
int listenFd_;                    // 监听套接字
int epollFd_;                     // epoll 文件描述符
std::unordered_map<int, std::unique_ptr<Connection>> connections_;  // 连接映射
RequestHandler requestHandler_;    // 请求处理回调
std::atomic<bool> running_;       // 运行状态标志
```

**工作流程**：
1. `listen()`: 创建 socket → 设置非阻塞 → bind → listen → 创建 epoll
2. `run()`: epoll_wait 循环 → 处理事件（接受连接/读写数据）
3. `handleAccept()`: 循环 accept（ET 模式需要循环读取直到 EAGAIN）
4. `handleEvent()`: 根据事件类型调用 Connection 的 onReadable/onWritable

**技术要点**：
- ✅ 非阻塞 I/O（`O_NONBLOCK`）
- ✅ 边缘触发模式（`EPOLLET`）
- ✅ SO_REUSEADDR 选项（快速重启）
- ✅ 连接管理使用 `std::unique_ptr`（RAII）

---

#### 1.2 Connection（连接管理）
**文件**：`Connection.hpp/cpp`

**核心职责**：
- 管理单个 TCP 连接的读写缓冲区
- 处理数据的接收和发送
- 判断请求完整性并触发回调

**关键实现**：
```cpp
int fd_;                          // 文件描述符
std::string readBuffer_;          // 读缓冲区
std::string writeBuffer_;         // 写缓冲区
RequestHandler handler_;          // 请求处理回调
bool closed_;                     // 连接状态
```

**工作流程**：
1. `onReadable()`: recv 数据 → 追加到 readBuffer → 检测 `\r\n\r\n`（HTTP 结束标志）→ 调用 handler
2. `onWritable()`: 从 writeBuffer 发送数据 → 更新缓冲区

**技术要点**：
- ✅ 简单的 HTTP 请求完整性判断（查找 `\r\n\r\n`）
- ✅ 非阻塞发送（处理 EAGAIN）
- ✅ RAII 管理文件描述符

---

#### 1.3 HttpParser（HTTP 解析器）
**文件**：`HttpParser.hpp/cpp`

**核心职责**：
- 解析 HTTP 请求（方法、路径、查询参数、头部、Body）
- 构建 HTTP 响应

**数据结构**：
```cpp
struct HttpRequest {
    std::string method;           // GET/POST
    std::string path;             // /api/v1/device/report
    std::string query;            // device_id=xxx&limit=100
    std::unordered_map<std::string, std::string> headers;  // 请求头
    std::string body;             // 请求体（JSON）
};
```

**实现方式**：
- 使用 `std::istringstream` 逐行解析
- 解析请求行：提取方法、路径、查询参数
- 解析头部：键值对存储
- 根据 `Content-Length` 读取 Body

**技术要点**：
- ✅ 简易实现（不支持 chunked 编码等高级特性）
- ✅ 支持 GET 查询参数解析
- ✅ 支持 POST Body 解析

---

### 2. 业务逻辑模块（business/）

#### 2.1 ReportHandler（请求处理）
**文件**：`ReportHandler.hpp/cpp`

**核心职责**：
- 处理设备数据上报请求
- 处理设备数据查询请求
- 解析请求参数并调用存储层

**数据结构**：
```cpp
struct ReportRequest {
    std::string deviceId;         // 设备 ID
    long long timestamp;           // 时间戳
    std::unordered_map<std::string, double> metrics;  // 指标数据
};

struct QueryRequest {
    std::string deviceId;         // 设备 ID
    std::size_t limit;            // 查询条数限制
};
```

**工作流程**：
1. `handleReport()`: 解析 JSON → 自动注册设备 → 构造 DataPoint → 写入存储 → 返回成功响应
2. `handleQuery()`: 解析查询参数 → 从存储查询数据 → 构造 JSON 响应

**技术要点**：
- ✅ 自动设备注册（首次上报时）
- ✅ 参数验证和错误处理
- ✅ JSON 序列化/反序列化

---

#### 2.2 DeviceManager（设备管理）
**文件**：`DeviceManager.hpp/cpp`

**核心职责**：
- 管理已注册的设备集合
- 提供设备存在性检查和自动注册

**实现方式**：
```cpp
std::mutex mtx_;                          // 互斥锁
std::unordered_set<std::string> devices_; // 设备集合
```

**技术要点**：
- ✅ 使用 `std::mutex` 保护并发访问
- ✅ `ensureRegistered()` 幂等操作（多次调用安全）

---

### 3. 存储模块（storage/）

#### 3.1 MemoryStore（内存存储）
**文件**：`MemoryStore.hpp/cpp`

**核心职责**：
- 存储设备数据点（时间序列数据）
- 提供高效的读写操作

**数据结构**：
```cpp
struct DataPoint {
    long long timestamp;                              // 时间戳
    std::unordered_map<std::string, double> metrics;  // 指标数据
};

// 存储结构
std::shared_mutex mtx_;                                    // 读写锁
std::unordered_map<std::string, std::vector<DataPoint>> data_;  // 设备ID -> 数据序列
```

**实现方式**：
- **写入**：使用 `std::unique_lock`（独占锁）
- **读取**：使用 `std::shared_lock`（共享锁，允许多读）

**技术要点**：
- ✅ **读写分离设计**：读操作不阻塞其他读操作，提高并发性能
- ✅ 使用 `std::shared_mutex`（C++17）
- ✅ 查询时返回最近 N 条数据（从后往前取）

---

### 4. 线程模块（thread/）

#### 4.1 ThreadPool（线程池）
**文件**：`ThreadPool.hpp/cpp`

**核心职责**：
- 管理线程池，执行异步任务
- 当前项目中**未使用**，但已实现

**实现方式**：
```cpp
std::vector<std::thread> workers_;        // 工作线程
BlockingQueue<Task> taskQueue_;           // 任务队列
std::atomic<bool> running_;               // 运行状态
```

**工作流程**：
1. `start()`: 创建 N 个工作线程
2. `submit()`: 提交任务到队列
3. `workerLoop()`: 线程从队列取任务并执行
4. `stop()`: 发送退出信号，等待线程结束

---

#### 4.2 BlockingQueue（阻塞队列）
**文件**：`BlockingQueue.hpp`

**核心职责**：
- 提供线程安全的阻塞队列
- 支持生产者和消费者模式

**实现方式**：
```cpp
std::mutex mtx_;                          // 互斥锁
std::condition_variable cv_;              // 条件变量
std::queue<T> queue_;                     // 队列
```

**技术要点**：
- ✅ 使用 `std::condition_variable` 实现阻塞等待
- ✅ 模板类设计，可存储任意类型

---

### 5. 工具模块（utils/）

#### 5.1 Logger（日志系统）
**文件**：`Logger.hpp/cpp`

**核心职责**：
- 提供日志记录功能
- 支持不同日志级别（DEBUG/INFO/WARN/ERROR）

**实现方式**：
```cpp
enum class LogLevel { DEBUG, INFO, WARN, ERROR };
static std::mutex mtx_;                   // 线程安全
static std::ofstream ofs_;                // 文件输出流
```

**使用方式**：
```cpp
LOG_INFO("Server listening on 0.0.0.0:8080");
LOG_ERROR("Failed to start server");
```

**技术要点**：
- ✅ 线程安全（互斥锁保护）
- ✅ 支持文件输出和标准错误输出
- ✅ 时间戳格式化

---

#### 5.2 JsonParser（JSON 解析器）
**文件**：`JsonParser.hpp/cpp`

**核心职责**：
- 解析 JSON 字符串
- 序列化 JSON 对象

**数据结构**：
```cpp
class JsonValue {
    using Value = std::variant<
        std::nullptr_t, bool, long long, double, std::string,
        std::unordered_map<std::string, JsonValue>,  // 对象
        std::vector<JsonValue>                       // 数组
    >;
};
```

**实现方式**：
- **解析**：递归下降解析器
  - `parseValue()` → `parseObject()` / `parseArray()` / `parseString()` / `parseNumber()`
- **序列化**：递归遍历 JsonValue，生成 JSON 字符串

**技术要点**：
- ✅ 使用 `std::variant`（C++17）实现类型安全的 JSON 值
- ✅ 支持基本类型、对象、数组
- ✅ 字符串转义处理
- ⚠️ **限制**：不支持嵌套对象、复杂数组等（简易实现）

---

## 🔄 程序执行流程

### 启动流程
```
main()
  ├─ Logger::init()              # 初始化日志
  ├─ 创建 MemoryStore            # 存储模块
  ├─ 创建 DeviceManager          # 设备管理
  ├─ 创建 ReportHandler          # 业务处理
  ├─ 创建 TcpServer              # TCP 服务器
  ├─ server.setRequestHandler()  # 设置请求处理回调
  ├─ server.listen()             # 绑定端口，创建 epoll
  └─ server.run()                # 启动事件循环（在单独线程）
```

### 请求处理流程（上报）
```
客户端发送 POST /api/v1/device/report
  ↓
TcpServer::run() → epoll_wait 检测到可读事件
  ↓
Connection::onReadable() → recv 数据 → 检测到完整请求
  ↓
调用 requestHandler_ 回调
  ↓
main.cpp 中的 lambda：
  ├─ HttpParser::parseRequest()      # 解析 HTTP 请求
  ├─ JsonParser::parse()             # 解析 JSON Body
  ├─ ReportHandler::parseReportRequest()  # 解析业务请求
  ├─ ReportHandler::handleReport()   # 处理上报
  │   ├─ DeviceManager::ensureRegistered()  # 注册设备
  │   └─ MemoryStore::append()       # 写入数据
  ├─ JsonParser::stringify()         # 序列化响应
  └─ HttpParser::buildResponse()     # 构建 HTTP 响应
  ↓
Connection::onWritable() → send 响应数据
```

### 请求处理流程（查询）
```
客户端发送 GET /api/v1/device/query?device_id=xxx&limit=100
  ↓
TcpServer::run() → epoll_wait 检测到可读事件
  ↓
Connection::onReadable() → recv 数据 → 检测到完整请求
  ↓
调用 requestHandler_ 回调
  ↓
main.cpp 中的 lambda：
  ├─ HttpParser::parseRequest()      # 解析 HTTP 请求
  ├─ ReportHandler::parseQueryRequest()  # 解析查询参数
  ├─ ReportHandler::handleQuery()    # 处理查询
  │   └─ MemoryStore::queryLatest()  # 查询数据（共享锁）
  ├─ JsonParser::stringify()         # 序列化响应
  └─ HttpParser::buildResponse()     # 构建 HTTP 响应
  ↓
Connection::onWritable() → send 响应数据
```

---

## 🎯 核心技术点总结

### 1. 高并发网络编程
- **epoll**：Linux 高效的 I/O 多路复用机制
- **Reactor 模式**：事件驱动的网络编程模型
- **边缘触发（ET）**：减少系统调用，提高性能
- **非阻塞 I/O**：避免线程阻塞，支持高并发

### 2. 并发控制
- **读写锁（shared_mutex）**：读多写少场景的性能优化
- **互斥锁（mutex）**：保护共享资源
- **原子变量（atomic）**：无锁的状态标志

### 3. 内存管理
- **RAII**：使用智能指针自动管理资源
- **std::unique_ptr**：独占所有权，自动释放
- **移动语义**：减少不必要的拷贝

### 4. 数据结构选择
- **std::unordered_map**：O(1) 查找，适合设备ID映射
- **std::vector**：连续内存，适合时间序列数据
- **std::variant**：类型安全的联合体（JSON 值）

### 5. 设计模式
- **回调模式**：RequestHandler 函数对象
- **单例模式**：Logger 静态成员
- **工厂模式**：JsonParser 静态方法

---

## 📊 性能特点

### 优势
1. ✅ **高并发**：epoll + 非阻塞 I/O，支持万级连接
2. ✅ **读写分离**：共享锁允许多读并发
3. ✅ **内存存储**：无磁盘 I/O，响应速度快
4. ✅ **边缘触发**：减少系统调用次数

### 限制
1. ⚠️ **内存限制**：数据仅存储在内存，重启丢失
2. ⚠️ **简易实现**：HTTP/JSON 解析器功能有限
3. ⚠️ **单线程处理**：业务逻辑在主线程执行（可扩展为多线程）

---

## 🚀 扩展建议

### 1. 持久化存储
- 集成 MySQL/SQLite 存储历史数据
- 使用 Redis 作为缓存层

### 2. 多线程处理
- 使用已实现的 ThreadPool 处理业务逻辑
- 实现多 Reactor 模式（多 epoll 实例）

### 3. 功能增强
- 支持更完善的 JSON 解析（嵌套对象、数组）
- 支持 HTTP chunked 编码
- 添加配置管理（配置文件/环境变量）
- 添加监控和指标收集

### 4. 错误处理
- 更完善的错误处理和重试机制
- 连接超时管理
- 请求限流和熔断

---

## 📚 学习要点

### 对于初学者
1. **理解 epoll 工作原理**：事件驱动的 I/O 模型
2. **理解 Reactor 模式**：事件循环 + 回调处理
3. **理解非阻塞 I/O**：为什么需要非阻塞 + 缓冲区
4. **理解读写锁**：读多写少场景的优化

### 对于进阶学习
1. **性能优化**：如何进一步提升并发性能
2. **内存管理**：RAII、智能指针的使用
3. **并发编程**：锁的选择和使用场景
4. **网络编程**：TCP/IP 协议栈的理解

---

## 📝 总结

这是一个**结构清晰、实现完整**的高并发 C++ 后端服务项目，涵盖了：
- ✅ 网络编程（epoll、TCP、HTTP）
- ✅ 并发编程（锁、原子变量）
- ✅ 数据结构设计（内存存储）
- ✅ 业务逻辑处理（设备管理、数据上报/查询）
- ✅ 工具模块（日志、JSON 解析）

适合作为学习 Linux C++ 后端开发的**优秀参考项目**！
